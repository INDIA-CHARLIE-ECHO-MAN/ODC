"text/comma-separated-values,text/plain",
".csv")
),
#      tags$hr(),
#      checkboxInput("header", "Header", TRUE)
),
mainPanel(
tableOutput("contents")
)
)
)
server <- function(input, output) {
output$contents <- renderTable({
# input$file1 will be NULL initially. After the user selects
# and uploads a file, it will be a data frame with 'name',
# 'size', 'type', and 'datapath' columns. The 'datapath'
# column will contain the local filenames where the data can
# be found.
inFile <- input$file1
if (is.null(inFile))
return(NULL)
read.csv(inFile$datapath, header = input$header)
})
}
shinyApp(ui, server)
}
## Only run examples in interactive R sessions
if (interactive()) {
ui <- fluidPage(
sidebarLayout(
sidebarPanel(
fileInput("file1", "Choose CSV File",
accept = c(
"text/csv",
"text/comma-separated-values,text/plain",
".csv")
)#,
#      tags$hr(),
#      checkboxInput("header", "Header", TRUE)
),
mainPanel(
tableOutput("contents")
)
)
)
server <- function(input, output) {
output$contents <- renderTable({
# input$file1 will be NULL initially. After the user selects
# and uploads a file, it will be a data frame with 'name',
# 'size', 'type', and 'datapath' columns. The 'datapath'
# column will contain the local filenames where the data can
# be found.
inFile <- input$file1
if (is.null(inFile))
return(NULL)
read.csv(inFile$datapath, header = input$header)
})
}
shinyApp(ui, server)
}
## Only run examples in interactive R sessions
library("shiny")
if (interactive()) {
ui <- fluidPage(
sidebarLayout(
sidebarPanel(
fileInput("file1", "Choose CSV File",
accept = c(
"text/csv",
"text/comma-separated-values,text/plain",
".csv")
)#,
#      tags$hr(),
#      checkboxInput("header", "Header", TRUE)
),
mainPanel(
tableOutput("contents")
)
)
)
server <- function(input, output) {
output$contents <- renderTable({
# input$file1 will be NULL initially. After the user selects
# and uploads a file, it will be a data frame with 'name',
# 'size', 'type', and 'datapath' columns. The 'datapath'
# column will contain the local filenames where the data can
# be found.
inFile <- input$file1
if (is.null(inFile))
return(NULL)
#    read.csv(inFile$datapath, header = input$header)
read.csv(inFile$datapath)
})
}
shinyApp(ui, server)
}
library(shiny)
# Define the fields we want to save from the form
fields <- c("name")
# Shiny app with 3 fields that the user can submit data for
shinyApp(
ui = fluidPage(
#tableOutput("responses"),
DT::dataTableOutput("responses"), #tags$hr(),
textInput("name", "Name", ""),
#    checkboxInput("used_shiny", "I've built a Shiny app in R before", FALSE),
#    sliderInput("r_num_years", "Number of years using R",
#                0, 25, 2, ticks = FALSE),
actionButton("submit", "Submit")
),
server = function(input, output, session) {
saveData <- function(data) {
data <- as.data.frame(t(data))
if (exists("responses")) {
responses <<- rbind(responses, data)
} else {
responses <<- data
}
}
loadData <- function() {
if (exists("responses")) {
responses
}
}
# Whenever a field is filled, aggregate all form data
formData <- reactive({
data <- sapply(fields, function(x) input[[x]])
data
})
# When the Submit button is clicked, save the form data
observeEvent(input$submit, {
saveData(formData())
})
# Show the previous responses
# (update with current response when Submit is clicked)
output$responses <- DT::renderDataTable({
input$submit
loadData()
})
}
)
}
library(shiny)
# Define the fields we want to save from the form
fields <- c("name")
# Shiny app with 3 fields that the user can submit data for
shinyApp(
ui = fluidPage(
tableOutput("responses"),
#DT::dataTableOutput("responses"), #tags$hr(),
textInput("name", "Name", ""),
#    checkboxInput("used_shiny", "I've built a Shiny app in R before", FALSE),
#    sliderInput("r_num_years", "Number of years using R",
#                0, 25, 2, ticks = FALSE),
actionButton("submit", "Submit")
),
server = function(input, output, session) {
saveData <- function(data) {
data <- as.data.frame(t(data))
if (exists("responses")) {
responses <<- rbind(responses, data)
} else {
responses <<- data
}
}
loadData <- function() {
if (exists("responses")) {
responses
}
}
# Whenever a field is filled, aggregate all form data
formData <- reactive({
data <- sapply(fields, function(x) input[[x]])
data
})
# When the Submit button is clicked, save the form data
observeEvent(input$submit, {
saveData(formData())
})
# Show the previous responses
# (update with current response when Submit is clicked)
output$responses <- DT::renderDataTable({
input$submit
loadData()
})
}
)
library(shiny)
# Define the fields we want to save from the form
fields <- c("name")
# Shiny app with 3 fields that the user can submit data for
shinyApp(
ui = fluidPage(
tableOutput("responses"),
#DT::dataTableOutput("responses"), #tags$hr(),
textInput("name"),
#    checkboxInput("used_shiny", "I've built a Shiny app in R before", FALSE),
#    sliderInput("r_num_years", "Number of years using R",
#                0, 25, 2, ticks = FALSE),
actionButton("submit", "Submit")
),
server = function(input, output, session) {
saveData <- function(data) {
data <- as.data.frame(t(data))
if (exists("responses")) {
responses <<- rbind(responses, data)
} else {
responses <<- data
}
}
loadData <- function() {
if (exists("responses")) {
responses
}
}
# Whenever a field is filled, aggregate all form data
formData <- reactive({
data <- sapply(fields, function(x) input[[x]])
data
})
# When the Submit button is clicked, save the form data
observeEvent(input$submit, {
saveData(formData())
})
# Show the previous responses
# (update with current response when Submit is clicked)
output$responses <- DT::renderDataTable({
input$submit
loadData()
})
}
)
library(shiny)
# Define the fields we want to save from the form
fields <- c("name")
# Shiny app with 3 fields that the user can submit data for
shinyApp(
ui = fluidPage(
tableOutput("responses"),
#DT::dataTableOutput("responses"), #tags$hr(),
textInput("name"),
#    checkboxInput("used_shiny", "I've built a Shiny app in R before", FALSE),
#    sliderInput("r_num_years", "Number of years using R",
#                0, 25, 2, ticks = FALSE),
actionButton("submit", "Submit")
),
server = function(input, output, session) {
saveData <- function(data) {
data <- as.data.frame(t(data))
if (exists("responses")) {
responses <<- rbind(responses, data)
} else {
responses <<- data
}
}
loadData <- function() {
if (exists("responses")) {
responses
}
}
# Whenever a field is filled, aggregate all form data
formData <- reactive({
data <- sapply(fields, function(x) input[[x]])
data
})
# When the Submit button is clicked, save the form data
observeEvent(input$submit, {
saveData(formData())
})
# Show the previous responses
# (update with current response when Submit is clicked)
output$responses <- tableOutput()({
input$submit
loadData()
})
}
)
library(shiny)
# Define the fields we want to save from the form
fields <- c("name")
# Shiny app with 3 fields that the user can submit data for
shinyApp(
ui = fluidPage(
tableOutput("responses"),
#DT::dataTableOutput("responses"), #tags$hr(),
textInput("name", "Name"),
#    checkboxInput("used_shiny", "I've built a Shiny app in R before", FALSE),
#    sliderInput("r_num_years", "Number of years using R",
#                0, 25, 2, ticks = FALSE),
actionButton("submit", "Submit")
),
server = function(input, output, session) {
saveData <- function(data) {
data <- as.data.frame(t(data))
if (exists("responses")) {
responses <<- rbind(responses, data)
} else {
responses <<- data
}
}
loadData <- function() {
if (exists("responses")) {
responses
}
}
# Whenever a field is filled, aggregate all form data
formData <- reactive({
data <- sapply(fields, function(x) input[[x]])
data
})
# When the Submit button is clicked, save the form data
observeEvent(input$submit, {
saveData(formData())
})
# Show the previous responses
# (update with current response when Submit is clicked)
output$responses <- tableOutput()({
input$submit
loadData()
})
}
)
library(shiny); runApp('C:/UNSW/2022/t2/desn2000/ODC/reactiveproto.R')
runApp('C:/UNSW/2022/t2/desn2000/ODC')
runApp('C:/UNSW/2022/t2/desn2000/ODC')
runApp('C:/UNSW/2022/t2/desn2000/ODC/god.R')
## Only run examples in interactive R sessions
if (interactive()) {
ui <- fluidPage(
p("The first radio button group controls the second"),
radioButtons("inRadioButtons", "Input radio buttons",
c("Item A", "Item B", "Item C")),
radioButtons("inRadioButtons2", "Input radio buttons 2",
c("Item A", "Item B", "Item C"))
)
server <- function(input, output, session) {
observe({
x <- input$inRadioButtons
# Can also set the label and select items
updateRadioButtons(session, "inRadioButtons2",
label = paste("radioButtons label", x),
choices = x,
selected = x
)
})
}
shinyApp(ui, server)
}
## Only run examples in interactive R sessions
library("shiny")
## Only run examples in interactive R sessions
library("shiny")
if (interactive()) {
ui <- fluidPage(
p("The first radio button group controls the second"),
radioButtons("inRadioButtons", "Input radio buttons",
c("Item A", "Item B", "Item C")),
radioButtons("inRadioButtons2", "Input radio buttons 2",
c("Item A", "Item B", "Item C"))
)
server <- function(input, output, session) {
observe({
x <- input$inRadioButtons
# Can also set the label and select items
updateRadioButtons(session, "inRadioButtons2",
label = paste("radioButtons label", x),
choices = x,
selected = x
)
})
}
shinyApp(ui, server)
}
runApp('C:/UNSW/2022/t2/desn2000/ODC')
runApp('C:/UNSW/2022/t2/desn2000/ODC')
## Only run examples in interactive R sessions
library("shiny")
if (interactive()) {
ui <- fluidPage(
sidebarLayout(
sidebarPanel(
fileInput("file1", "Choose CSV File", accept = ".csv"),
checkboxInput("header", "Header", TRUE)
),
mainPanel(
tableOutput("contents")
)
)
)
server <- function(input, output) {
output$contents <- renderTable({
file <- input$file1
ext <- tools::file_ext(file$datapath)
req(file)
validate(need(ext == c("csv", "tsv", "txt"), "Please upload a csv, tsv or txt file."))
read.csv(file$datapath, header = input$header)
})
}
shinyApp(ui, server)
}
shiny::runApp('C:/UNSW/2022/t2/desn2000/ODC')
ls
pwd
shiny::runApp('C:/UNSW/2022/t2/desn2000/ODC')
runApp('C:/UNSW/2022/t2/desn2000/ODC')
runApp('C:/UNSW/2022/t2/desn2000/ODC')
if (interactive()) {
library(shiny)
library(shinyWidgets)
ui <- fluidPage(
pickerInput(
inputId = "month",
label = "Select a month",
choices = c("Blood", "Brain", "Tissue"),
)
)
server <- function(input, output, session) {
}
shinyApp(ui, server)
}
if (interactive()) {
library(shiny)
library(shinyWidgets)
ui <- fluidPage(
pickerInput(
inputId = "month",
label = "Select a month",
choices = c("Blood", "Brain", "Tissue"),
)
)
server <- function(input, output, session) {
}
shinyApp(ui, server)
}
runApp('C:/UNSW/2022/t2/desn2000/ODC/SHIN18proto/loadRData.R')
download_network_hdf5(network_type="generic")
download_network_hdf5(network_type="blood")
download_network_hdf5(network_type="brain")
library("shiny")
download_network_hdf5(network_type="generic")
download_network_hdf5(network_type="blood")
download_network_hdf5(network_type="brain")
devtools::install_github("ballouzlab/OutDeCo_lite")
library(OutDeCo)
download_network_hdf5(network_type="generic")
download_network_hdf5(network_type="blood")
download_network_hdf5(network_type="brain")
download_network_hdf5(network_type="brain")
network_type <- 'generic'
gene_list <- sample(  EGAD::attr.human$name[EGAD::attr.human$chr=="chrX"], 100 )
runApp('C:/UNSW/2022/t2/desn2000/ODC/SHIN18proto/blobdatabases.R')
runApp('C:/UNSW/2022/t2/desn2000/ODC/SHIN18proto/blobdatabases.R')
load("res_brain.RData")
if (FALSE) {
# Per-session reactive file reader
function(input, output, session) {
fileData <- reactiveFileReader(1000, session, 'data.csv', read.csv)
output$data <- renderTable({
fileData()
})
}
# Cross-session reactive file reader. In this example, all sessions share
# the same reader, so read.csv only gets executed once no matter how many
# user sessions are connected.
fileData <- reactiveFileReader(1000, NULL, 'data.csv', read.csv)
function(input, output, session) {
output$data <- renderTable({
fileData()
})
}
}
library(shiny)
if (FALSE) {
# Per-session reactive file reader
function(input, output, session) {
fileData <- reactiveFileReader(1000, session, 'data.csv', read.csv)
output$data <- renderTable({
fileData()
})
}
# Cross-session reactive file reader. In this example, all sessions share
# the same reader, so read.csv only gets executed once no matter how many
# user sessions are connected.
fileData <- reactiveFileReader(1000, NULL, 'data.csv', read.csv)
function(input, output, session) {
output$data <- renderTable({
fileData()
})
}
}
file.env <- LoadToEnvironment('res_brain.RData')
LoadToEnvironment <- function(RData, env = new.env()){
load(RData, env)
return(env)
}
file.env <- LoadToEnvironment('res_brain.RData')
a <- c(10,20,30,40)
b <- c('book', 'pen', 'textbook', 'pencil_case')
c <- c(TRUE,FALSE,TRUE,FALSE)
d <- c(2.5, 8, 10, 7)
# Join the variables to create a data frame
df <- data.frame(a,b,c,d)
View(df)
pwd
setwd
setwd("C:/UNSW/2022/t2/desn2000/ODC")
file.env <- LoadToEnvironment('res_brain.RData')
View(file.env)
load("res_brain.RData")
View(res_brain)
runApp()
runApp()
